//
// This file was generated by the Eclipse Implementation of JAXB, v4.0.5 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
//


package engine;

import engine.instruction.*;
import jakarta.xml.bind.annotation.*;
import jakarta.xml.bind.annotation.adapters.XmlJavaTypeAdapter;

import java.io.Serializable;
import java.util.*;


@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
    "sInstruction"
})
@XmlRootElement(name = "S-Instructions")
public class SInstructions implements Serializable, SInstructionsView {

    @XmlElement(name = "S-Instruction", required = true)
    @XmlJavaTypeAdapter(SInstructionAdapter.class)
    private List<SInstruction> sInstruction;

    public SInstructions() {
        this.sInstruction = new ArrayList<>();
        updateInstructionsLines();
    }

    public SInstructions(List<SInstruction> sInstruction) {
        this.sInstruction = sInstruction;
        updateInstructionsLines();
    }

    public void updateInstructionsLines(){
        for(int i = 0; i < sInstruction.size(); i++){
            sInstruction.get(i).setLine(i+1);
        }
    }

    @Override
    public SInstruction getInstruction(int line_num) {
        return sInstruction.get(line_num - 1);
    }

    public void append(SInstruction instruction){
        instruction.setLine(sInstruction.size()+1);
        sInstruction.add(instruction);

    }

    // Returns list of input variables used in program in order
    @Override
    public List<String> getInputVariablesUsed() {
        Set<String> vars = new LinkedHashSet<>(); // prevents duplicates automatically

        for (int line = 1; line <= size(); line++) {
            SInstruction instr = getInstruction(line);

            String variable = instr.getSVariable();
            if (variable.matches("^(x[1-9][0-9]*)$"))
                vars.add(variable);

            String argVariable = instr.getArgumentVariable();
            if (argVariable.matches("^(x[1-9][0-9]*)$"))
                vars.add(argVariable);

            if (instr.getInstructionName() == InstructionName.QUOTE) {
                QuoteInstruction quoteInstruction = (QuoteInstruction) instr;
                vars.addAll(
                        quoteInstruction.getInputVariablesFromArguments().stream()
                                .filter(v -> v.matches("^(x[1-9][0-9]*)$"))
                                .toList()
                );
            }
        }

        // sort by numeric part
        List<String> sortedVars = new ArrayList<>(vars);
        sortedVars.sort(Comparator.comparingInt(v -> Integer.parseInt(v.substring(1))));

        return sortedVars;
    }

    @Override
    public int getMaxDegree(){
        int max_degree = 0;
        for(int line = 1; line <= size(); line++){
            int currDegree = getInstruction(line).getDegree();
            if(max_degree < currDegree){
                max_degree = currDegree;
            }
        }
        return max_degree;
    }

    // validates that all used labels jump to a line
    @Override
    public void validateLabelsUsed() throws InvalidInstructionException {

        for(int line = 1; line <= size(); line++){
            String argLabel = this.getInstruction(line).getArgumentLabel();
            if(!argLabel.isEmpty() && !argLabel.equals("EXIT")){
                boolean found = false;
                for(int line2 = 1; line2 <= size(); line2++){
                    String sLabel = this.getInstruction(line2).getSLabel();
                    if(sLabel.equals(argLabel)){
                        found = true;
                    }
                }
                if(!found){
                    throw new InvalidInstructionException(String.format("Instruction #%d, label %s does not jump anywhere",
                            line, argLabel));
                }
            }
        }

    }

    @Override
    public int getMaxUsedLabel(){
        int max_label_num = 1;
        for(int line = 1; line <= size(); line++){
            String sLabel = getInstruction(line).getSLabel();
            if(sLabel.startsWith("L")) {
                int label_num = Integer.parseInt(sLabel.substring(1));
                if (label_num > max_label_num) {
                    max_label_num = label_num;
                }
            }
        }
        return max_label_num;
    }

    @Override
    public int getMaxUsedZVariable(){
        int max_z_var = 1;
        for(int line = 1; line <= size(); line++){
            String sVariable = getInstruction(line).getSVariable();
            if(sVariable.startsWith("z")) {
                int var_num = Integer.parseInt(sVariable.substring(1));
                if (var_num > max_z_var) {
                    max_z_var = var_num;
                }
            }
        }
        return max_z_var;
    }

    // returns list of labels used in order, but keeps EXIT as last.
    @Override
    public List<String> getLabelsUsed() {
        boolean hasExit = false;
        Set<String> labels = new HashSet<>();

        for (int line = 1; line <= size(); line++) {
            String label = getInstruction(line).getSLabel();
            String argLabel = getInstruction(line).getArgumentLabel();

            if (label != null && !label.isEmpty()) {
                if (label.equals("EXIT")) {
                    hasExit = true;
                } else {
                    labels.add(label);
                }
            }

            if (argLabel != null && !argLabel.isEmpty()) {
                if (argLabel.equals("EXIT")) {
                    hasExit = true;
                } else {
                    labels.add(argLabel);
                }
            }
        }

        List<String> result = labels.stream()
                .sorted(Comparator.comparingInt(v -> Integer.parseInt(v.substring(1))))
                .toList();

        if (hasExit) {
            result = new ArrayList<>(result); // make mutable
            result.add("EXIT");
        }

        return result;
    }

    @Override
    public List<String> getVariablesUsed(){
        List<String> vars = new ArrayList<>();

        for (int line = 1; line <= size(); line++){
            SInstruction instr = this.getInstruction(line);

            List<String> candidates = new ArrayList<>();
            candidates.add(instr.getSVariable());
            candidates.add(instr.getArgumentVariable());

            if (instr.getInstructionName() == InstructionName.QUOTE) {
                QuoteInstruction quoteInstruction = (QuoteInstruction) instr;
                candidates.addAll(quoteInstruction.getInputVariablesFromArguments());
            }

            vars.addAll(
                    candidates.stream()
                            .filter(v -> v != null && v.matches("^(y|([xz][1-9][0-9]*))$"))
                            .filter(v -> !vars.contains(v))
                            .toList()
            );
        }

        vars.sort(Comparator
                .comparingInt((String v) -> v.equals("y") ? 0 : 1) // y first
                .thenComparing(v -> v.charAt(0)) // x before z
                .thenComparingInt(v -> v.equals("y") ? 0 : Integer.parseInt(v.substring(1))) // numeric
        );
        return vars;
    }


    public void addAll(List<SInstruction> instructions){
        sInstruction.addAll(instructions);
    }

    public void appendInstruction(SInstruction instr){
        sInstruction.add(instr);
    }

    @Override
    public List<SInstruction> getAllInstructions(){
        return Collections.unmodifiableList(sInstruction);
    }

    @Override
    public int size(){
        return sInstruction.size();
    }


}
